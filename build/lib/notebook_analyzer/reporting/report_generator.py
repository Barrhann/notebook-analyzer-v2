"""
Report Generator module
Created by: Barrhann
"""

from typing import Dict, Any, Union
from datetime import datetime

class ReportGenerator:
    def generate(self, code_analysis: Dict[str, Any], doc_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """
        Generate a comprehensive report from code and documentation analysis.

        Args:
            code_analysis (Dict[str, Any]): Results from code format analysis
            doc_analysis (Dict[str, Any]): Results from documentation analysis

        Returns:
            Dict[str, Any]: Structured report with business insights
        """
        # Get total violations (handling both list and int types)
        pep8_violations = code_analysis.get('pep8_violations', 0)
        total_violations = (
            len(pep8_violations) if isinstance(pep8_violations, list)
            else pep8_violations
        )

        report = {
            'summary': {
                'overall_quality_score': self._calculate_quality_score(code_analysis, doc_analysis),
                'total_issues': total_violations,
                'documentation_coverage': self._calculate_doc_coverage(doc_analysis),
                'generated_by': 'Barrhann',
                'generation_date': '2025-02-15 00:18:42 UTC'
            },
            'code_quality': {
                'pep8_compliance': self._summarize_pep8(code_analysis),
                'code_metrics': code_analysis.get('code_style_metrics', {})
            },
            'documentation_quality': {
                'markdown_analysis': doc_analysis.get('markdown_metrics', {}),
                'code_comments': doc_analysis.get('code_comments_metrics', {})
            },
            'findings': {
                'positive': code_analysis.get('positive_findings', []) +
                           doc_analysis.get('positive_findings', []),
                'negative': code_analysis.get('negative_findings', []) +
                           doc_analysis.get('negative_findings', [])
            }
        }
        
        return report

    def generate_text_report(self, code_analysis: Dict[str, Any], doc_analysis: Dict[str, Any]) -> str:
        """
        Generate a human-readable text report from the analysis results.

        Args:
            code_analysis (Dict[str, Any]): Results from code format analysis
            doc_analysis (Dict[str, Any]): Results from documentation analysis

        Returns:
            str: Formatted text report
        """
        report_dict = self.generate(code_analysis, doc_analysis)
        
        # Create sections of the report
        header = self._format_header()
        summary = self._format_summary(report_dict['summary'])
        code_quality = self._format_code_quality(report_dict['code_quality'])
        doc_quality = self._format_doc_quality(report_dict['documentation_quality'])
        findings = self._format_findings(report_dict['findings'])
        
        # Combine all sections
        sections = [
            header,
            summary,
            code_quality,
            doc_quality,
            findings
        ]
        
        return "\n\n".join(sections)

    def _format_header(self) -> str:
        return f"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   JUPYTER NOTEBOOK ANALYSIS REPORT                â•‘
â•‘                                                                  â•‘
â•‘  Generated by: Barrhann                                         â•‘
â•‘  Date: 2025-02-15 00:18:42 UTC                                 â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

    def _format_summary(self, summary: Dict[str, Any]) -> str:
        return f"""
ðŸ“Š EXECUTIVE SUMMARY
-------------------
Overall Quality Score: {summary['overall_quality_score']:.1f}/100
Total Issues Found: {summary['total_issues']}
Documentation Coverage: {summary['documentation_coverage']:.1f}%
"""

    def _format_code_quality(self, code_quality: Dict[str, Any]) -> str:
        pep8_status = "âœ… Compliant" if code_quality['pep8_compliance']['is_compliant'] else "âŒ Non-compliant"
        
        return f"""
ðŸ’» CODE QUALITY ANALYSIS
----------------------
PEP8 Status: {pep8_status}
Total PEP8 Violations: {code_quality['pep8_compliance']['total_violations']}

Code Metrics:
- Total Lines of Code: {code_quality['code_metrics'].get('total_lines', 0)}
- Average Line Length: {code_quality['code_metrics'].get('avg_line_length', 0):.1f} characters
- Complex Lines: {code_quality['code_metrics'].get('complex_lines', 0)}
"""

    def _format_doc_quality(self, doc_quality: Dict[str, Any]) -> str:
        markdown = doc_quality['markdown_analysis']
        comments = doc_quality['code_comments']
        
        return f"""
ðŸ“š DOCUMENTATION QUALITY
----------------------
Markdown Analysis:
- Total Markdown Cells: {markdown.get('total_cells', 0)}
- Cells with Headers: {markdown.get('cells_with_headers', 0)}
- Average Cell Length: {markdown.get('avg_length', 0):.1f} characters

Code Comments Analysis:
- Total Code Lines: {comments.get('total_lines', 0)}
- Commented Lines: {comments.get('commented_lines', 0)}
- Comment Ratio: {comments.get('comment_ratio', 0):.2%}
- Docstrings Found: {comments.get('docstring_count', 0)}
"""

    def _format_findings(self, findings: Dict[str, Any]) -> str:
        positive = "\n".join(f"âœ… {finding}" for finding in findings.get('positive', []))
        negative = "\n".join(f"âŒ {finding}" for finding in findings.get('negative', []))
        
        return f"""
ðŸŽ¯ KEY FINDINGS
-------------
Positive Aspects:
{positive or "No positive findings"}

Areas for Improvement:
{negative or "No areas requiring improvement"}

ðŸ’¡ RECOMMENDATIONS
----------------
1. {'Address PEP8 violations to improve code quality.' if negative else 'Maintain current code quality standards.'}
2. {'Increase code comments to improve maintainability.' if 'Insufficient code comments' in negative else 'Maintain current documentation practices.'}
3. {'Add more detailed markdown documentation.' if 'Markdown documentation could be more detailed' in negative else 'Continue with current documentation level.'}
"""

    def _calculate_quality_score(self, code_analysis: Dict[str, Any],
                               doc_analysis: Dict[str, Any]) -> float:
        """Calculate overall quality score based on various metrics."""
        score = 100.0
        
        # Deduct points for PEP8 violations
        pep8_violations = code_analysis.get('pep8_violations', 0)
        total_violations = (
            len(pep8_violations) if isinstance(pep8_violations, list)
            else pep8_violations
        )
        score -= min(30, total_violations * 2)  # Max 30 points deduction
        
        # Add points for documentation
        doc_metrics = doc_analysis.get('markdown_metrics', {})
        if doc_metrics.get('total_cells', 0) > 0:
            score += min(20, doc_metrics.get('cells_with_headers', 0) * 5)
        
        # Add points for code comments
        comment_metrics = doc_analysis.get('code_comments_metrics', {})
        if comment_metrics.get('comment_ratio', 0) > 0.2:
            score += 10
        
        return max(0, min(100, score))

    def _calculate_doc_coverage(self, doc_analysis: Dict[str, Any]) -> float:
        """Calculate documentation coverage percentage."""
        markdown_metrics = doc_analysis.get('markdown_metrics', {})
        comment_metrics = doc_analysis.get('code_comments_metrics', {})
        
        total_content = (markdown_metrics.get('total_cells', 0) +
                        comment_metrics.get('total_lines', 0))
        total_documented = (markdown_metrics.get('cells_with_headers', 0) +
                          comment_metrics.get('commented_lines', 0))
        
        if total_content == 0:
            return 0.0
            
        return (total_documented / total_content) * 100

    def _summarize_pep8(self, code_analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Summarize PEP8 compliance information."""
        pep8_violations = code_analysis.get('pep8_violations', 0)
        total_violations = (
            len(pep8_violations) if isinstance(pep8_violations, list)
            else pep8_violations
        )
            
        return {
            'total_violations': total_violations,
            'is_compliant': total_violations == 0,
            'violations_summary': {}  # Could be expanded to group by violation type
        }
